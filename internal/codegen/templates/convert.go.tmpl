// Code generated by terraform-provider-libvirt codegen. DO NOT EDIT.

package generated

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"libvirt.org/go/libvirtxml"
)

var (
	_ = fmt.Sprintf                 // Avoid unused import errors
	_ = basetypes.ObjectAsOptions{} // Avoid unused import errors
	_ = types.StringNull()          // Avoid unused import errors
)

{{- range .Structs }}

{{- if .IsExcluded }}
// {{ .Name }}FromXML requires manual implementation.
// Reason: {{ .ExclusionReason }}
// See internal/codegen/exclusions/exclusions.go and README.md

// {{ .Name }}ToXML requires manual implementation.
// Reason: {{ .ExclusionReason }}
// See internal/codegen/exclusions/exclusions.go and README.md
{{- else }}
// {{ .Name }}FromXML converts libvirtxml.{{ .Name }} to {{ .Name }}Model.
// The plan parameter is used to preserve user intent for optional fields.
func {{ .Name }}FromXML(ctx context.Context, xml *libvirtxml.{{ .Name }}, plan *{{ .Name }}Model) (*{{ .Name }}Model, error) {
	if xml == nil {
		return nil, nil
	}

	model := &{{ .Name }}Model{}

	{{- range .Fields }}
	{{- if and (not .IsExcluded) (not .IsCycle) (not .IsFlattenedUnit) (not .IsFlattenedAttr) }}
	{{ template "fromXMLField" . }}
	{{- end }}
	{{- end }}

	return model, nil
}

// {{ .Name }}ToXML converts {{ .Name }}Model to libvirtxml.{{ .Name }}.
func {{ .Name }}ToXML(ctx context.Context, model *{{ .Name }}Model) (*libvirtxml.{{ .Name }}, error) {
	if model == nil {
		return nil, nil
	}

	xml := &libvirtxml.{{ .Name }}{}

	{{- range .Fields }}
	{{- if and (not .IsExcluded) (not .IsCycle) (not .IsFlattenedUnit) (not .IsFlattenedAttr) }}
	{{ template "toXMLField" . }}
	{{- end }}
	{{- end }}

	return xml, nil
}
{{- end }}
{{- end }}

{{- define "fromXMLField" }}
{{- if .IsFlattenedValue }}
	// Flattened chardata+attributes field: {{ .GoName }}
	{{- $valueField := .NestedStruct.ValueWithUnitPattern.ValueFieldName }}
	{{- $alwaysRead := .IsComputed }}
	plan{{ .GoName }}HasValue := plan != nil && !plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown()
	if plan == nil || {{ if $alwaysRead }}true{{ else }}false{{ end }} {
		{{- if .IsPointer }}
		if xml.{{ .GoName }} != nil {
			{{- if eq .TFType "types.String" }}
			model.{{ .GoName }} = types.StringValue(xml.{{ .GoName }}.{{ $valueField }})
			{{- else }}
			model.{{ .GoName }} = types.Int64Value(int64(xml.{{ .GoName }}.{{ $valueField }}))
			{{- end }}
			{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
			{{- if eq .GoType "string" }}
			if xml.{{ $.GoName }}.{{ .GoName }} != "" {
				model.{{ $.GoName }}{{ .GoName }} = types.StringValue(xml.{{ $.GoName }}.{{ .GoName }})
			} else {
				model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
			}
			{{- else }}
			if xml.{{ $.GoName }}.{{ .GoName }} != 0 {
				model.{{ $.GoName }}{{ .GoName }} = types.Int64Value(int64(xml.{{ $.GoName }}.{{ .GoName }}))
			} else {
				model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
			}
			{{- end }}
			{{- end }}
		} else {
			{{- if eq .TFType "types.String" }}
			model.{{ .GoName }} = types.StringNull()
			{{- else }}
			model.{{ .GoName }} = types.Int64Null()
			{{- end }}
			{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
			{{- if eq .GoType "string" }}
			model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
			{{- else }}
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
			{{- end }}
			{{- end }}
		}
		{{- else }}
		{{- if eq .TFType "types.String" }}
		model.{{ .GoName }} = types.StringValue(xml.{{ .GoName }}.{{ $valueField }})
		{{- else }}
		model.{{ .GoName }} = types.Int64Value(int64(xml.{{ .GoName }}.{{ $valueField }}))
		{{- end }}
		{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
		{{- if eq .GoType "string" }}
		if xml.{{ $.GoName }}.{{ .GoName }} != "" {
			model.{{ $.GoName }}{{ .GoName }} = types.StringValue(xml.{{ $.GoName }}.{{ .GoName }})
		} else {
			model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
		}
		{{- else }}
		if xml.{{ $.GoName }}.{{ .GoName }} != 0 {
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Value(int64(xml.{{ $.GoName }}.{{ .GoName }}))
		} else {
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
		}
		{{- end }}
		{{- end }}
		{{- end }}
	} else if plan{{ .GoName }}HasValue {
		model.{{ .GoName }} = plan.{{ .GoName }}
	} else {
		{{- if eq .TFType "types.String" }}
		model.{{ .GoName }} = types.StringNull()
		{{- else }}
		model.{{ .GoName }} = types.Int64Null()
		{{- end }}
	}
	{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
	if plan == nil {
		{{- if $.IsPointer }}
		if xml.{{ $.GoName }} != nil {
			{{- if eq .GoType "string" }}
			if xml.{{ $.GoName }}.{{ .GoName }} != "" {
				model.{{ $.GoName }}{{ .GoName }} = types.StringValue(xml.{{ $.GoName }}.{{ .GoName }})
			} else {
				model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
			}
			{{- else }}
			if xml.{{ $.GoName }}.{{ .GoName }} != 0 {
				model.{{ $.GoName }}{{ .GoName }} = types.Int64Value(int64(xml.{{ $.GoName }}.{{ .GoName }}))
			} else {
				model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
			}
			{{- end }}
		} else {
			{{- if eq .GoType "string" }}
			model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
			{{- else }}
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
			{{- end }}
		}
		{{- else }}
		{{- if eq .GoType "string" }}
		if xml.{{ $.GoName }}.{{ .GoName }} != "" {
			model.{{ $.GoName }}{{ .GoName }} = types.StringValue(xml.{{ $.GoName }}.{{ .GoName }})
		} else {
			model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
		}
		{{- else }}
		if xml.{{ $.GoName }}.{{ .GoName }} != 0 {
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Value(int64(xml.{{ $.GoName }}.{{ .GoName }}))
		} else {
			model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
		}
		{{- end }}
		{{- end }}
	} else if !plan.{{ $.GoName }}{{ .GoName }}.IsNull() && !plan.{{ $.GoName }}{{ .GoName }}.IsUnknown() {
		model.{{ $.GoName }}{{ .GoName }} = plan.{{ $.GoName }}{{ .GoName }}
	} else {
		{{- if eq .GoType "string" }}
		model.{{ $.GoName }}{{ .GoName }} = types.StringNull()
		{{- else }}
		model.{{ $.GoName }}{{ .GoName }} = types.Int64Null()
		{{- end }}
	}
	{{- end }}
{{- else if and .IsList .IsNested }}
	// List of nested objects: {{ .GoName }}
	if plan == nil || (!plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown()) {
		if len(xml.{{ .GoName }}) > 0 {
			var list{{ .GoName }} []{{ .NestedStruct.Name }}Model
			var plan{{ .GoName }} []{{ .NestedStruct.Name }}Model
			if plan != nil && !plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown() {
				if diags := plan.{{ .GoName }}.ElementsAs(ctx, &plan{{ .GoName }}, false); diags.HasError() {
					return nil, fmt.Errorf("extracting {{ .GoName }} list elements: %s", diags.Errors()[0].Summary())
				}
			}
			xmlItems := xml.{{ .GoName }}
			limit := len(xmlItems)
			if plan{{ .GoName }} != nil && len(plan{{ .GoName }}) < limit {
				limit = len(plan{{ .GoName }})
			}
			if plan == nil {
				limit = len(xmlItems)
			}
			for idx := 0; idx < limit; idx++ {
				item := xmlItems[idx]
				var nestedPlan *{{ .NestedStruct.Name }}Model
				if plan{{ .GoName }} != nil && idx < len(plan{{ .GoName }}) {
					nestedPlan = &plan{{ .GoName }}[idx]
				}
				{{- if .IsPointer }}
				converted, err := {{ .NestedStruct.Name }}FromXML(ctx, item, nestedPlan)
				{{- else }}
				converted, err := {{ .NestedStruct.Name }}FromXML(ctx, &item, nestedPlan)
				{{- end }}
				if err != nil {
					return nil, err
				}
				if converted != nil {
					list{{ .GoName }} = append(list{{ .GoName }}, *converted)
				}
			}
			listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: {{ .NestedStruct.Name }}AttributeTypes()}, list{{ .GoName }})
			if diags.HasError() {
				return nil, fmt.Errorf("converting {{ .GoName }} to List: %s", diags.Errors()[0].Summary())
			}
			model.{{ .GoName }} = listVal
		} else {
			model.{{ .GoName }} = types.ListNull(types.ObjectType{AttrTypes: {{ .NestedStruct.Name }}AttributeTypes()})
		}
	} else {
		model.{{ .GoName }} = types.ListNull(types.ObjectType{AttrTypes: {{ .NestedStruct.Name }}AttributeTypes()})
	}
{{- else if .IsList }}
	// List of simple values: {{ .GoName }}
	if plan == nil || (!plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown()) {
		if len(xml.{{ .GoName }}) > 0 {
			values := xml.{{ .GoName }}
			if plan != nil && !plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown() {
				if count := len(plan.{{ .GoName }}.Elements()); count < len(values) {
					values = values[:count]
				}
			}
			listVal, diags := types.ListValueFrom(ctx, {{ .ElementType }}, values)
			if diags.HasError() {
				return nil, fmt.Errorf("converting {{ .GoName }} to List: %s", diags.Errors()[0].Summary())
			}
			model.{{ .GoName }} = listVal
		} else {
			model.{{ .GoName }} = types.ListNull({{ .ElementType }})
		}
	} else {
		model.{{ .GoName }} = types.ListNull({{ .ElementType }})
	}
{{- else if .IsNested }}
	// Nested field: {{ .GoName }}
	{{- if .IsPointer }}
	// Only populate if in plan or no plan (import/datasource)
	if plan == nil || (!plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown()) {
		if xml.{{ .GoName }} != nil {
			// Extract nested plan for user intent preservation
			var nested{{ .GoName }}Plan *{{ .NestedStruct.Name }}Model
			if plan != nil && !plan.{{ .GoName }}.IsNull() {
				var planObj {{ .NestedStruct.Name }}Model
				if diags := plan.{{ .GoName }}.As(ctx, &planObj, basetypes.ObjectAsOptions{}); !diags.HasError() {
					nested{{ .GoName }}Plan = &planObj
				}
			}

			nested{{ .GoName }}, err := {{ .NestedStruct.Name }}FromXML(ctx, xml.{{ .GoName }}, nested{{ .GoName }}Plan)
			if err != nil {
				return nil, err
			}
			if nested{{ .GoName }} != nil {
				objVal, diags := types.ObjectValueFrom(ctx, {{ .NestedStruct.Name }}AttributeTypes(), nested{{ .GoName }})
				if diags.HasError() {
					return nil, fmt.Errorf("converting {{ .GoName }} to Object: %s", diags.Errors()[0].Summary())
				}
				model.{{ .GoName }} = objVal
			} else {
				model.{{ .GoName }} = types.ObjectNull({{ .NestedStruct.Name }}AttributeTypes())
			}
		} else {
			model.{{ .GoName }} = types.ObjectNull({{ .NestedStruct.Name }}AttributeTypes())
		}
	} else {
		model.{{ .GoName }} = types.ObjectNull({{ .NestedStruct.Name }}AttributeTypes())
	}
	{{- else }}
	{
		nested{{ .GoName }}, err := {{ .NestedStruct.Name }}FromXML(ctx, &xml.{{ .GoName }}, nil)
		if err != nil {
			return nil, err
		}
		if nested{{ .GoName }} != nil {
			objVal, diags := types.ObjectValueFrom(ctx, {{ .NestedStruct.Name }}AttributeTypes(), nested{{ .GoName }})
			if diags.HasError() {
				return nil, fmt.Errorf("converting {{ .GoName }} to Object: %s", diags.Errors()[0].Summary())
			}
			model.{{ .GoName }} = objVal
		} else {
			model.{{ .GoName }} = types.ObjectNull({{ .NestedStruct.Name }}AttributeTypes())
		}
	}
	{{- end}}
{{- else if .IsRequired }}
	// Required field: {{ .GoName }}
	{{- if .StringToBool }}
	// String-to-bool conversion: {{ .StringToBool.TrueValue }}/{{ .StringToBool.FalseValue }}
	model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }} == "{{ .StringToBool.TrueValue }}")
	{{- else if eq .TFType "types.String" }}
	model.{{ .GoName }} = types.StringValue(xml.{{ .GoName }})
	{{- else if eq .TFType "types.Int64" }}
	model.{{ .GoName }} = types.Int64Value(int64(xml.{{ .GoName }}))
	{{- else if eq .TFType "types.Bool" }}
	model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }})
	{{- end }}
{{- else if .IsComputed }}
	// Computed field: {{ .GoName }}
	{{- if eq .TFType "types.String" }}
		{{- if .IsPointer }}
	if xml.{{ .GoName }} != nil && *xml.{{ .GoName }} != "" {
		model.{{ .GoName }} = types.StringValue(*xml.{{ .GoName }})
	} else {
		model.{{ .GoName }} = types.StringNull()
	}
		{{- else }}
	if xml.{{ .GoName }} != "" {
		model.{{ .GoName }} = types.StringValue(xml.{{ .GoName }})
	} else {
		model.{{ .GoName }} = types.StringNull()
	}
		{{- end }}
	{{- else if eq .TFType "types.Int64" }}
		{{- if .IsPointer }}
	if xml.{{ .GoName }} != nil && *xml.{{ .GoName }} != 0 {
		model.{{ .GoName }} = types.Int64Value(int64(*xml.{{ .GoName }}))
	} else {
		model.{{ .GoName }} = types.Int64Null()
	}
		{{- else }}
	if xml.{{ .GoName }} != 0 {
		model.{{ .GoName }} = types.Int64Value(int64(xml.{{ .GoName }}))
	} else {
		model.{{ .GoName }} = types.Int64Null()
	}
		{{- end }}
	{{- else if eq .TFType "types.Bool" }}
		{{- if .IsPointer }}
	if xml.{{ .GoName }} != nil {
		model.{{ .GoName }} = types.BoolValue(*xml.{{ .GoName }})
	} else {
		model.{{ .GoName }} = types.BoolNull()
	}
		{{- else }}
	model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }})
		{{- end }}
	{{- end }}
{{- else }}
	// Optional field: {{ .GoName }}
	{{- if .StringToBool }}
	// String-to-bool conversion: {{ .StringToBool.TrueValue }}/{{ .StringToBool.FalseValue }}
	if plan == nil || (!plan.{{ .GoName }}.IsNull() && !plan.{{ .GoName }}.IsUnknown()) {
		{{- if .IsPointer }}
		if xml.{{ .GoName }} != nil {
			model.{{ .GoName }} = types.BoolValue(*xml.{{ .GoName }} == "{{ .StringToBool.TrueValue }}")
		} else {
			model.{{ .GoName }} = types.BoolNull()
		}
		{{- else }}
		if xml.{{ .GoName }} != "" {
			model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }} == "{{ .StringToBool.TrueValue }}")
		} else {
			model.{{ .GoName }} = types.BoolNull()
		}
		{{- end }}
	} else {
		model.{{ .GoName }} = types.BoolNull()
	}
	{{- else }}
	// If plan is nil (import/datasource), populate if present in XML
	// If plan exists, only populate if user specified it (preserve user intent)
	if plan == nil || !plan.{{ .GoName }}.IsNull() {
		{{- if eq .TFType "types.String" }}
		{{- if .IsPointer }}
		if xml.{{ .GoName }} != nil && *xml.{{ .GoName }} != "" {
			model.{{ .GoName }} = types.StringValue(*xml.{{ .GoName }})
		} else {
			model.{{ .GoName }} = types.StringNull()
		}
		{{- else }}
		if xml.{{ .GoName }} != "" {
			model.{{ .GoName }} = types.StringValue(xml.{{ .GoName }})
		} else {
			model.{{ .GoName }} = types.StringNull()
		}
		{{- end }}
		{{- else if eq .TFType "types.Int64" }}
		{{- if .IsPointer }}
		if xml.{{ .GoName }} != nil && *xml.{{ .GoName }} != 0 {
			model.{{ .GoName }} = types.Int64Value(int64(*xml.{{ .GoName }}))
		} else {
			model.{{ .GoName }} = types.Int64Null()
		}
		{{- else }}
		if xml.{{ .GoName }} != 0 {
			model.{{ .GoName }} = types.Int64Value(int64(xml.{{ .GoName }}))
		} else {
			model.{{ .GoName }} = types.Int64Null()
		}
		{{- end }}
		{{- else if eq .TFType "types.Bool" }}
		{{- if .IsPresenceBoolean }}
		// Boolean-to-presence: true if element present, false otherwise
		model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }} != nil)
		{{- else if .IsPointer }}
		if xml.{{ .GoName }} != nil {
			model.{{ .GoName }} = types.BoolValue(*xml.{{ .GoName }})
		} else {
			model.{{ .GoName }} = types.BoolNull()
		}
		{{- else }}
		model.{{ .GoName }} = types.BoolValue(xml.{{ .GoName }})
		{{- end }}
		{{- end }}
	} else {
		{{- if eq .TFType "types.String" }}
		model.{{ .GoName }} = types.StringNull()
		{{- else if eq .TFType "types.Int64" }}
		model.{{ .GoName }} = types.Int64Null()
		{{- else if eq .TFType "types.Bool" }}
		model.{{ .GoName }} = types.BoolNull()
		{{- end }}
	}
	{{- end }}
{{- end }}
{{- end }}

{{- define "toXMLField" }}
{{- if .IsFlattenedValue }}
	// Flattened chardata+attributes field: {{ .GoName }}
	if !model.{{ .GoName }}.IsNull() {
		{{- $valueType := .NestedStruct.ValueWithUnitPattern.ValueGoType }}
		{{- $valueField := .NestedStruct.ValueWithUnitPattern.ValueFieldName }}
		{{- if .IsPointer }}
		xml.{{ .GoName }} = &libvirtxml.{{ .NestedStruct.Name }}{
			{{- if eq .TFType "types.String" }}
			{{ $valueField }}: model.{{ .GoName }}.ValueString(),
			{{- else if eq $valueType "uint" }}
			{{ $valueField }}: uint(model.{{ .GoName }}.ValueInt64()),
			{{- else if eq $valueType "uint64" }}
			{{ $valueField }}: uint64(model.{{ .GoName }}.ValueInt64()),
			{{- else }}
			{{ $valueField }}: {{ $valueType }}(model.{{ .GoName }}.ValueInt64()),
			{{- end }}
		}
		// Set attributes if user specified them
		{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
		if !model.{{ $.GoName }}{{ .GoName }}.IsNull() {
			{{- if eq .GoType "string" }}
			xml.{{ $.GoName }}.{{ .GoName }} = model.{{ $.GoName }}{{ .GoName }}.ValueString()
			{{- else if eq .GoType "uint" }}
			xml.{{ $.GoName }}.{{ .GoName }} = uint(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- else if eq .GoType "uint64" }}
			xml.{{ $.GoName }}.{{ .GoName }} = uint64(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- else }}
			xml.{{ $.GoName }}.{{ .GoName }} = {{ .GoType }}(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- end }}
		}
		{{- end }}
		{{- else }}
		xml.{{ .GoName }} = libvirtxml.{{ .NestedStruct.Name }}{
			{{- if eq .TFType "types.String" }}
			{{ $valueField }}: model.{{ .GoName }}.ValueString(),
			{{- else if eq $valueType "uint" }}
			{{ $valueField }}: uint(model.{{ .GoName }}.ValueInt64()),
			{{- else if eq $valueType "uint64" }}
			{{ $valueField }}: uint64(model.{{ .GoName }}.ValueInt64()),
			{{- else }}
			{{ $valueField }}: {{ $valueType }}(model.{{ .GoName }}.ValueInt64()),
			{{- end }}
		}
		// Set attributes if user specified them
		{{- range .NestedStruct.ValueWithUnitPattern.AttributeFields }}
		if !model.{{ $.GoName }}{{ .GoName }}.IsNull() {
			{{- if eq .GoType "string" }}
			xml.{{ $.GoName }}.{{ .GoName }} = model.{{ $.GoName }}{{ .GoName }}.ValueString()
			{{- else if eq .GoType "uint" }}
			xml.{{ $.GoName }}.{{ .GoName }} = uint(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- else if eq .GoType "uint64" }}
			xml.{{ $.GoName }}.{{ .GoName }} = uint64(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- else }}
			xml.{{ $.GoName }}.{{ .GoName }} = {{ .GoType }}(model.{{ $.GoName }}{{ .GoName }}.ValueInt64())
			{{- end }}
		}
		{{- end }}
		{{- end }}
	}
{{- else if and .IsList .IsNested }}
	// List of nested objects: {{ .GoName }}
	if !model.{{ .GoName }}.IsNull() && !model.{{ .GoName }}.IsUnknown() {
		var list{{ .GoName }} []{{ .NestedStruct.Name }}Model
		diags := model.{{ .GoName }}.ElementsAs(ctx, &list{{ .GoName }}, false)
		if diags.HasError() {
			return nil, fmt.Errorf("extracting {{ .GoName }} list elements: %s", diags.Errors()[0].Summary())
		}
		for _, item := range list{{ .GoName }} {
			converted, err := {{ .NestedStruct.Name }}ToXML(ctx, &item)
			if err != nil {
				return nil, err
			}
			{{- if .IsPointer }}
			if converted != nil {
				xml.{{ .GoName }} = append(xml.{{ .GoName }}, converted)
			}
			{{- else }}
			if converted != nil {
				xml.{{ .GoName }} = append(xml.{{ .GoName }}, *converted)
			}
			{{- end }}
		}
	}
{{- else if .IsList }}
	// List of simple values: {{ .GoName }}
	if !model.{{ .GoName }}.IsNull() && !model.{{ .GoName }}.IsUnknown() {
		diags := model.{{ .GoName }}.ElementsAs(ctx, &xml.{{ .GoName }}, false)
		if diags.HasError() {
			return nil, fmt.Errorf("extracting {{ .GoName }} list elements: %s", diags.Errors()[0].Summary())
		}
	}
{{- else if .IsNested }}
	// Nested field: {{ .GoName }}
	if !model.{{ .GoName }}.IsNull() && !model.{{ .GoName }}.IsUnknown() {
		var nested{{ .GoName }} {{ .NestedStruct.Name }}Model
		diags := model.{{ .GoName }}.As(ctx, &nested{{ .GoName }}, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, fmt.Errorf("converting {{ .GoName }} from Object: %s", diags.Errors()[0].Summary())
		}
		converted{{ .GoName }}, err := {{ .NestedStruct.Name }}ToXML(ctx, &nested{{ .GoName }})
		if err != nil {
			return nil, err
		}
		{{- if .IsPointer }}
		xml.{{ .GoName }} = converted{{ .GoName }}
		{{- else }}
		if converted{{ .GoName }} != nil {
			xml.{{ .GoName }} = *converted{{ .GoName }}
		}
		{{- end }}
	}
{{- else }}
	// Field: {{ .GoName }}
	{{- if .StringToBool }}
	// Bool-to-string conversion: {{ .StringToBool.TrueValue }}/{{ .StringToBool.FalseValue }}
	if !model.{{ .GoName }}.IsNull() {
		{{- if .IsPointer }}
		if model.{{ .GoName }}.ValueBool() {
			val := "{{ .StringToBool.TrueValue }}"
			xml.{{ .GoName }} = &val
		} else {
			val := "{{ .StringToBool.FalseValue }}"
			xml.{{ .GoName }} = &val
		}
		{{- else }}
		if model.{{ .GoName }}.ValueBool() {
			xml.{{ .GoName }} = "{{ .StringToBool.TrueValue }}"
		} else {
			xml.{{ .GoName }} = "{{ .StringToBool.FalseValue }}"
		}
		{{- end }}
	}
	{{- else if eq .TFType "types.String" }}
	if !model.{{ .GoName }}.IsNull() {
		{{- if .IsPointer }}
		val := model.{{ .GoName }}.ValueString()
		xml.{{ .GoName }} = &val
		{{- else }}
		xml.{{ .GoName }} = model.{{ .GoName }}.ValueString()
		{{- end }}
	}
	{{- else if eq .TFType "types.Int64" }}
	if !model.{{ .GoName }}.IsNull() {
		{{- if .IsPointer }}
		{{- if eq .GoType "*int" }}
		val := int(model.{{ .GoName }}.ValueInt64())
		xml.{{ .GoName }} = &val
		{{- else if eq .GoType "*uint" }}
		val := uint(model.{{ .GoName }}.ValueInt64())
		xml.{{ .GoName }} = &val
		{{- else if eq .GoType "*uint64" }}
		val := uint64(model.{{ .GoName }}.ValueInt64())
		xml.{{ .GoName }} = &val
		{{- else }}
		val := int64(model.{{ .GoName }}.ValueInt64())
		xml.{{ .GoName }} = &val
		{{- end }}
		{{- else }}
		{{- if eq .GoType "int" }}
		xml.{{ .GoName }} = int(model.{{ .GoName }}.ValueInt64())
		{{- else if eq .GoType "uint" }}
		xml.{{ .GoName }} = uint(model.{{ .GoName }}.ValueInt64())
		{{- else if eq .GoType "uint64" }}
		xml.{{ .GoName }} = uint64(model.{{ .GoName }}.ValueInt64())
		{{- else }}
		xml.{{ .GoName }} = int64(model.{{ .GoName }}.ValueInt64())
		{{- end }}
		{{- end }}
	}
	{{- else if eq .TFType "types.Bool" }}
	{{- if .IsPresenceBoolean }}
	// Boolean-to-presence: create empty struct if true
	if !model.{{ .GoName }}.IsNull() && model.{{ .GoName }}.ValueBool() {
		xml.{{ .GoName }} = &libvirtxml.{{ .NestedStruct.Name }}{}
	}
	{{- else }}
	if !model.{{ .GoName }}.IsNull() {
		{{- if .IsPointer }}
		val := model.{{ .GoName }}.ValueBool()
		xml.{{ .GoName }} = &val
		{{- else }}
		xml.{{ .GoName }} = model.{{ .GoName }}.ValueBool()
		{{- end }}
	}
	{{- end }}
	{{- end }}
{{- end }}
{{- end }}
